// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {ContractOwnershipStorage} from "./../access/libraries/ContractOwnershipStorage.sol";
import {PauseStorage} from "./../lifecycle/libraries/PauseStorage.sol";
import {ContractOwnership} from "./../access/ContractOwnership.sol";
import {Pause} from "./../lifecycle/Pause.sol";

/// @title CumulativeMerkleClaim
/// @notice This contract is designed for claiming payouts which will cumulate over time.
/// @notice A merkle tree is generated with one leaf for each claim recipient together with the description of the claim (claimData).
/// @notice Flow: when new claims become available, the contract is paused to avoid further claims, a new tree is generated by summing up the current
/// @notice unclaimed payouts and the new payouts, per user. The new tree is set and replaces the previous one and the contract is unpaused.
/// @notice A nonce is used for each new tree and is included in every leaf to prevent collisions with claims from previous trees.
abstract contract CumulativeMerkleClaim is Pause {
    using MerkleProof for bytes32[];
    using ContractOwnershipStorage for ContractOwnershipStorage.Layout;
    using PauseStorage for PauseStorage.Layout;

    bytes32 public root;
    uint256 public nonce;

    mapping(bytes32 => bool) public claimed;

    /// @notice Emitted when a new merkle root is set.
    /// @param root The new merkle root.
    event MerkleRootSet(bytes32 root);

    /// @notice Emitted when a payout is claimed.
    /// @param root The merkle root on which the claim was made.
    /// @param recipient The recipient of the claim.
    /// @param claimData The encoded claim data for the claim.
    /// @param nonce The nonce as when the claim was made.
    event PayoutClaimed(bytes32 indexed root, address indexed recipient, bytes claimData, uint256 nonce);

    /// @notice Thrown when trying to claim the same leaf more than once.
    /// @param recipient The recipient of the claim.
    /// @param claimData The encoded claim data for the claim.
    /// @param nonce The nonce as when the claim was made.
    error AlreadyClaimed(address recipient, bytes claimData, uint256 nonce);

    /// @notice Thrown when a proof cannot be verified.
    /// @param recipient The recipient of the claim.
    /// @param claimData The encoded claim data for the claim.
    /// @param nonce The nonce as when the claim was made.
    error InvalidProof(address recipient, bytes claimData, uint256 nonce);

    constructor() Pause(true) ContractOwnership(msg.sender) {}

    /// @notice Sets the merkle root for a new claiming period and unpauses the contract.
    /// @dev Reverts with {NotContractOwner} if the sender is not the contract owner.
    /// @dev Reverts with {NotPaused} if the contract is not paused.
    /// @dev Emits an {Unpaused} event.
    /// @dev Emits a {MerkleRootSet} event.
    /// @param merkleRoot The merkle root to set.
    function setMerkleRoot(bytes32 merkleRoot) public {
        ContractOwnershipStorage.layout().enforceIsContractOwner(_msgSender());
        PauseStorage.layout().unpause();
        root = merkleRoot;
        unchecked {
            ++nonce;
        }
        emit MerkleRootSet(merkleRoot);
    }

    /// @notice Executes the payout for a given user (anyone can call this function).
    /// @dev Reverts with {Paused} if the contract is paused.
    /// @dev Reverts with {AlreadyClaimed} if this specific payout has already been claimed.
    /// @dev Reverts with {InvalidProof} if the merkle proof cannot be verified.
    /// @dev Emits a {PayoutClaimed} event.
    /// @param recipient Address of the user to claim the payout
    /// @param claimData Encoded claim data for `recipient`
    /// @param proof Merkle proof of the user based on the merkle root
    function claimPayout(address recipient, bytes calldata claimData, bytes32[] calldata proof) external {
        PauseStorage.layout().enforceIsNotPaused();

        uint256 currentNonce = nonce;
        bytes32 currentRoot = root;
        bytes32 leaf = keccak256(abi.encodePacked(recipient, claimData, currentNonce));

        if (claimed[leaf]) revert AlreadyClaimed(recipient, claimData, currentNonce);
        if (!proof.verifyCalldata(currentRoot, leaf)) revert InvalidProof(recipient, claimData, currentNonce);

        claimed[leaf] = true;

        emit PayoutClaimed(currentRoot, recipient, claimData, currentNonce);

        _distributePayout(recipient, claimData);
    }

    /// @notice Distributes the payout to the recipient.
    /// @dev This virtual function must be implemented by inheriting contracts.
    /// @param recipient Address of the user to claim the payout
    /// @param claimData Encoded claim data for `recipient`. The encoding is specific to the inheriting contract, for example a quantity of tokens.
    function _distributePayout(address recipient, bytes calldata claimData) internal virtual;
}
